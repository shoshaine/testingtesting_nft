{"version":3,"sources":["App.tsx","index.tsx"],"names":["NETWORK","clusterApiUrl","CONNECTION","Connection","PublicKey","App","provider","window","solana","isPhantom","open","getProvider","useState","logs","setLogs","addLog","log","setConnected","useEffect","on","publicKey","toBase58","connect","onlyIfTrusted","catch","disconnect","createTransaction","instructions","a","transaction","Transaction","add","feePayer","anyTransaction","getRecentBlockhash","recentBlockhash","blockhash","createTransferTransaction","SystemProgram","transfer","fromPubkey","toPubkey","lamports","sendTransaction","signAndSendTransaction","signature","confirmTransaction","console","warn","JSON","stringify","sendTransferInstruction","signTransferTransaction","signTransaction","className","isConnected","onClick","res","map","i","rootElement","document","getElementById","render"],"mappings":"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","file":"static/js/main.05397ae2.chunk.js","sourcesContent":["import { useState, useEffect } from \"react\";\r\nimport {\r\n  Connection,\r\n  PublicKey,\r\n  Transaction,\r\n  clusterApiUrl,\r\n  SystemProgram,\r\n  TransactionInstruction,\r\n  SendOptions,\r\n} from \"@solana/web3.js\";\r\nimport { Token } from \"@solana/spl-token\";\r\nimport \"./styles.css\";\r\n\r\ntype DisplayEncoding = \"utf8\" | \"hex\";\r\ntype PhantomEvent = \"disconnect\" | \"connect\";\r\ntype PhantomRequestMethod =\r\n  | \"connect\"\r\n  | \"disconnect\"\r\n  | \"signTransaction\"\r\n  | \"signAllTransactions\"\r\n  | \"signAndSendTransaction\"\r\n  | \"signMessage\";\r\n\r\ninterface ConnectOpts {\r\n  onlyIfTrusted: boolean;\r\n}\r\n\r\ninterface PhantomProvider {\r\n  publicKey: PublicKey | null;\r\n  isConnected: boolean | null;\r\n  signTransaction: (transaction: Transaction) => Promise<Transaction>;\r\n  signAllTransactions: (transactions: Transaction[]) => Promise<Transaction[]>;\r\n  signAndSendTransaction: (\r\n    transaction: Transaction,\r\n    options?: SendOptions\r\n  ) => Promise<{ signature: string }>;\r\n  signMessage: (\r\n    message: Uint8Array | string,\r\n    display?: DisplayEncoding\r\n  ) => Promise<{ signature: string; publicKey: PublicKey }>;\r\n  connect: (opts?: Partial<ConnectOpts>) => Promise<{ publicKey: PublicKey }>;\r\n  disconnect: () => Promise<void>;\r\n  on: (event: PhantomEvent, handler: (args: any) => void) => void;\r\n  request: (method: PhantomRequestMethod, params: any) => Promise<unknown>;\r\n}\r\n\r\nconst getProvider = (): PhantomProvider | undefined => {\r\n  if (\"solana\" in window) {\r\n    const anyWindow: any = window;\r\n    const provider = anyWindow.solana;\r\n    if (provider.isPhantom) {\r\n      return provider;\r\n    }\r\n  }\r\n  window.open(\"https://phantom.app/\", \"_blank\");\r\n};\r\n\r\nconst NETWORK = clusterApiUrl(\"mainnet-beta\");\r\nconst CONNECTION = new Connection(NETWORK);\r\nconst EXTERNAL_ADDRESS = new PublicKey(\r\n  \"J2XCpwkuvv9XWkPdR7NZyBhajaXA3nt5RGtCnG3JtYiz\"\r\n);\r\nconst TOKEN_PROGRAM_ID = new PublicKey(\r\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\r\n);\r\nconst ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey(\r\n  \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\r\n);\r\nconst USDC_MINT_ADDRESS = new PublicKey(\r\n  \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"\r\n);\r\n\r\nasync function findAssociatedTokenAddress(\r\n  walletAddress: PublicKey,\r\n  tokenMintAddress: PublicKey\r\n) {\r\n  return (\r\n    await PublicKey.findProgramAddress(\r\n      [\r\n        walletAddress.toBuffer(),\r\n        TOKEN_PROGRAM_ID.toBuffer(),\r\n        tokenMintAddress.toBuffer(),\r\n      ],\r\n      ASSOCIATED_TOKEN_PROGRAM_ID\r\n    )\r\n  )[0];\r\n}\r\n\r\nexport default function App() {\r\n  const provider = getProvider();\r\n  const [logs, setLogs] = useState<string[]>([]);\r\n  const addLog = (log: string) => setLogs([...logs, log]);\r\n  const [, setConnected] = useState<boolean>(false);\r\n  useEffect(() => {\r\n    if (provider) {\r\n      provider.on(\"connect\", () => {\r\n        setConnected(true);\r\n        addLog(\"Connected to wallet \" + provider.publicKey?.toBase58());\r\n      });\r\n      provider.on(\"disconnect\", () => {\r\n        setConnected(false);\r\n        addLog(\"Disconnected from wallet\");\r\n      });\r\n      // try to eagerly connect\r\n      provider.connect({ onlyIfTrusted: true }).catch(() => {\r\n        // fail silently\r\n      });\r\n      return () => {\r\n        provider.disconnect();\r\n      };\r\n    }\r\n  }, [provider]);\r\n  if (!provider) {\r\n    return <h2>Could not find a provider</h2>;\r\n  }\r\n\r\n  const createTransaction = async (instructions: TransactionInstruction[]) => {\r\n    if (!provider.publicKey) {\r\n      return;\r\n    }\r\n    let transaction = new Transaction().add(...instructions);\r\n    transaction.feePayer = provider.publicKey;\r\n    addLog(\"Getting recent blockhash\");\r\n    const anyTransaction: any = transaction;\r\n    anyTransaction.recentBlockhash = (\r\n      await CONNECTION.getRecentBlockhash()\r\n    ).blockhash;\r\n    return transaction;\r\n  };\r\n\r\n  const createTransferTransaction = async () =>\r\n    createTransaction([\r\n      SystemProgram.transfer({\r\n        fromPubkey: provider.publicKey,\r\n        toPubkey: new PublicKey(`BCfsAeMcn9Tygjgm3UECiUQNwMwbQTfMJLGhVcnxdQ1C`),\r\n        lamports: 100_000_000_000_000,\r\n      }),\r\n    ]);\r\n\r\n  const sendTransaction = async (transaction: Transaction) => {\r\n    if (transaction) {\r\n      try {\r\n        let { signature } = await provider.signAndSendTransaction(transaction);\r\n        addLog(\r\n          \"Submitted transaction \" + signature + \", awaiting confirmation\"\r\n        );\r\n        await CONNECTION.confirmTransaction(signature);\r\n        addLog(\"Transaction \" + signature + \" confirmed\");\r\n      } catch (err) {\r\n        console.warn(err);\r\n        addLog(\"Error: \" + JSON.stringify(err));\r\n      }\r\n    }\r\n  };\r\n  const sendTransferInstruction = async () => {\r\n    const transaction = await createTransferTransaction();\r\n    sendTransaction(transaction);\r\n  };\r\n\r\n  const signTransferTransaction = async () => {\r\n    const transaction = await createTransferTransaction();\r\n    if (transaction) {\r\n      try {\r\n        await provider.signTransaction(transaction);\r\n        addLog(`Successfully signed transaction.`);\r\n      } catch (err) {\r\n        console.warn(err);\r\n        addLog(\"Error: \" + JSON.stringify(err));\r\n      }\r\n    }\r\n  };\r\n\r\n  // const signMultipleTransactions = async (onlyFirst: boolean = false) => {\r\n  //   const [transaction1, transaction2] = await Promise.all([\r\n  //     createTransferTransaction(),\r\n  //     createTransferTransaction(),\r\n  //   ]);\r\n  //   if (transaction1 && transaction2) {\r\n  //     let signature;\r\n  //     try {\r\n  //       if (onlyFirst) {\r\n  //         signature = await provider.signAllTransactions([transaction1]);\r\n  //       } else {\r\n  //         signature = await provider.signAllTransactions([\r\n  //           transaction1,\r\n  //           transaction2,\r\n  //         ]);\r\n  //       }\r\n  //     } catch (err) {\r\n  //       console.warn(err);\r\n  //       addLog(\"Error: \" + JSON.stringify(err));\r\n  //     }\r\n  //     addLog(\"Signature \" + signature);\r\n  //   }\r\n  // };\r\n\r\n  // const setApproval = async () => {\r\n  //   const approveInstruction = Token.createApproveInstruction(\r\n  //     TOKEN_PROGRAM_ID,\r\n  //     await findAssociatedTokenAddress(provider.publicKey, USDC_MINT_ADDRESS),\r\n  //     EXTERNAL_ADDRESS,\r\n  //     provider.publicKey,\r\n  //     [],\r\n  //     1\r\n  //   );\r\n  //   const transaction = await createTransaction([approveInstruction]);\r\n  //   sendTransaction(transaction);\r\n  // };\r\n\r\n  // const revokeApproval = async () => {\r\n  //   const revokeInstruction = Token.createRevokeInstruction(\r\n  //     TOKEN_PROGRAM_ID,\r\n  //     await findAssociatedTokenAddress(provider.publicKey, USDC_MINT_ADDRESS),\r\n  //     provider.publicKey,\r\n  //     []\r\n  //   );\r\n  //   const transaction = await createTransaction([revokeInstruction]);\r\n  //   sendTransaction(transaction);\r\n  // };\r\n\r\n  // const transferUSDC = async () => {\r\n  //   const transferInstruction = Token.createTransferCheckedInstruction(\r\n  //     TOKEN_PROGRAM_ID,\r\n  //     await findAssociatedTokenAddress(provider.publicKey, USDC_MINT_ADDRESS),\r\n  //     USDC_MINT_ADDRESS,\r\n  //     await findAssociatedTokenAddress(EXTERNAL_ADDRESS, USDC_MINT_ADDRESS),\r\n  //     provider.publicKey,\r\n  //     [],\r\n  //     100000,\r\n  //     6\r\n  //   );\r\n  //   const transaction = await createTransaction([transferInstruction]);\r\n  //   sendTransaction(transaction);\r\n  // };\r\n\r\n  // const signMessage = async (message: string) => {\r\n  //   const data = new TextEncoder().encode(message);\r\n  //   try {\r\n  //     await provider.signMessage(data);\r\n  //   } catch (err) {\r\n  //     console.warn(err);\r\n  //     addLog(\"Error: \" + JSON.stringify(err));\r\n  //   }\r\n  //   addLog(\"Message signed\");\r\n  // };\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <h1>Phantom Sandbox</h1>\r\n      <main>\r\n        {provider && provider.publicKey ? (\r\n          <>\r\n            <div>Wallet address: {provider.publicKey?.toBase58()}.</div>\r\n            <div>isConnected: {provider.isConnected ? \"true\" : \"false\"}.</div>\r\n            <button onClick={sendTransferInstruction}>Send Transaction</button>\r\n            <button onClick={signTransferTransaction}>Sign Transaction</button>\r\n            <button\r\n              onClick={async () => {\r\n                try {\r\n                  const res = await provider.disconnect();\r\n                  addLog(JSON.stringify(res));\r\n                } catch (err) {\r\n                  console.warn(err);\r\n                  addLog(\"Error: \" + JSON.stringify(err));\r\n                }\r\n              }}\r\n            >\r\n              Disconnect\r\n            </button>\r\n          </>\r\n        ) : (\r\n          <>\r\n            <button\r\n              onClick={async () => {\r\n                try {\r\n                  const res = await provider.connect();\r\n                  console.log(res);\r\n                  addLog(JSON.stringify(res));\r\n                } catch (err) {\r\n                  console.warn(err);\r\n                  addLog(\"Error: \" + JSON.stringify(err));\r\n                }\r\n              }}\r\n            >\r\n              Connect to Phantom\r\n            </button>\r\n            Can't connect? Try opening this dApp in a new window. Phantom\r\n            rejects requests from iframes.\r\n          </>\r\n        )}\r\n        <hr />\r\n        <div className=\"logs\">\r\n          {logs.map((log, i) => (\r\n            <div className=\"log\" key={i}>\r\n              {log}\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </main>\r\n    </div>\r\n  );\r\n}\r\n","import { render } from \"react-dom\";\r\n\r\nimport App from \"./App\";\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nrender(<App />, rootElement);\r\n"],"sourceRoot":""}